<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>The Big Little Guide to Running Code in the Cloud(s)</title><meta name="description" content="This guide evaluates many of the code execution offerings available across AWS, Google, Azure, Heroku, Fly and Cloudflare."/><meta name="next-head-count" content="4"/><link rel="preload" href="_next/static/css/5fc65f991220c427.css" as="style"/><link rel="stylesheet" href="_next/static/css/5fc65f991220c427.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="_next/static/chunks/webpack-514908bffb652963.js" defer=""></script><script src="_next/static/chunks/framework-6e4ba497ae0c8a3f.js" defer=""></script><script src="_next/static/chunks/main-4cc32e52ef88f8fd.js" defer=""></script><script src="_next/static/chunks/pages/_app-859a8f91abab2976.js" defer=""></script><script src="_next/static/chunks/pages/the-big-little-guide-to-running-code-in-the-clouds-4020177dd7ea3ecb.js" defer=""></script><script src="_next/static/pkInIokvrXIdaP_t5UMJ1/_buildManifest.js" defer=""></script><script src="_next/static/pkInIokvrXIdaP_t5UMJ1/_ssgManifest.js" defer=""></script><script src="_next/static/pkInIokvrXIdaP_t5UMJ1/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="antialiased text-gray-900 px-4 py-10 max-w-3xl mx-auto sm:px-6 sm:py-12 lg:max-w-4xl lg:py-16 lg:px-8 xl:max-w-6xl"><article class="prose"><h1>The Big Little Guide to Running Code in the Cloud(s)</h1><p class="lead">There are now many ways to run code, from traditional servers to the new serverless to cutting-edge edge options. This guide evaluates many of the code execution offerings available across AWS, Google, Azure, Heroku, Fly and Cloudflare.</p><p>As software developers, we&#x27;ve come a long way... from fighting over limited time slices of lab computing, we&#x27;ve arrived at being able to instantly deploy and run code on servers in hundreds of edge data-centers in cities all over the world. This guide evaluates some of the cloud computing options that have become available over two decades—we&#x27;ll cover the offerings from the three major cloud providers, along with a few other companies building interesting options.</p><p>The common stages of application development are <em>writing</em> code, <em>packaging</em> code, <em>deploying</em> and <em>running</em> code. In this guide we&#x27;ll talk about advances in <em>packaging</em>, <em>deploying</em> and <em>running</em> code. We&#x27;ll also cover the basics of the infrastructure required to connect our applications to the rest of the internet, like load-balancers, request protocols and routing. We <em>won&#x27;t</em> be looking at databases, data storage, <a href="the-big-little-guide-to-message-queues/index.html">message queues</a>, and other advances here—these are all massive topics that deserve their own separate guides. We&#x27;ll be looking at three kinds of service providers: <em>IaaS</em> or <em>infrastructure-as-a-service</em>, <em>PaaS</em> or <em>platform-as-a-service</em>, and <em>FaaS</em> or <em>functions-as-a-service</em>.</p><p>An <em><strong>IaaS,</strong></em> or <em>infrastructure-as-a-service</em> system gives you all the basic building blocks necessary to run your application, and asks you to make all the decisions about how your application should run—and also do all the work required to setup, configure, maintain and monitor it. The building blocks might have some loose integrations with each other, but you&#x27;ll have to do most of the wiring to make them work together.</p><p>A <strong><em>PaaS</em></strong>, or <em>platform-as-a-service</em> system makes a lot of those decisions for you, and does a lot of the work itself. The servers are already configured correctly and high-performance request routing and monitoring is taken care of. Operational maintenance is also handled for you, with the PaaS employing a highly trained team of engineers on a 24/7/365 pager duty schedule to make sure everything is running according to your choices. All you need to do is submit the application, configure it, and make a few strategic choices about how you want things to work.</p><p>A <em><strong>FaaS</strong></em>, of <em>functions-as-a-service</em> system, works very differently. Your application is <em>not</em> a stand-alone system here—it&#x27;s a smaller piece of code that fits tightly into a much larger framework offered by the FaaS system. It cannot run independently—it needs to follow the technology, dependency, packaging, deployment and execution rules of the FaaS, and it can run only in the context of that FaaS. In exchange for conforming to these tight rules the FaaS offers you something that&#x27;s very hard, if not impossible, to achieve using any other kind of system. We&#x27;ll cover what “magic” a FaaS provides, along with what the tradeoffs are and how to reduce their impact on your work.</p><h2>Simple IaaS</h2><p>The simplest way to deploy an application on the cloud is to rent one server and deploy it there. AWS has <a href="https://aws.amazon.com/ec2/">EC2</a>, Google has <a href="https://cloud.google.com/compute">Compute Engine</a>—Azure doesn&#x27;t bother with a marketing department and just puts everyone in sales, so they just call them <a href="https://azure.microsoft.com/en-in/services/virtual-machines/">Virtual Machines</a>. As Azure very helpfully points out, these servers are all <em>virtual machines</em>. They&#x27;re real servers with CPU, RAM, disks and networking installed in a data-center building somewhere, and they&#x27;re either rented out to you as a whole, or split into smaller sections using <em>virtualization</em> hardware and software—hence the term “virtual” machines. This splitting is invisible to you, the customer—you&#x27;ll see each virtual section that you rent as a complete, isolated, fully functioning machine. There&#x27;s a lot of incredible engineering that goes into doing this securely <em>and</em> with high-performance—if you&#x27;re interested the <a href="https://aws.amazon.com/ec2/nitro/">AWS Nitro System</a> is worth reading up on.</p><p>Your server needs to be reachable on the internet, so the first thing it&#x27;ll have is an <a href="https://en.wikipedia.org/wiki/IPv4">IP address</a>. These are a pretty scarce resource, though—represented as four numbers from 0 to 255, there are only 4,294,967,296 (256 x 256 x 256 x 256) possible addresses, out of which fewer are usable and available. So the cloud providers will usually either give you any available address, or allow you to reserve one—often for free if you&#x27;re actually using it, but at extra charges if you&#x27;re squatting without using it. AWS calls this <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html">Elastic IP</a>, and Google calls it “<a href="https://cloud.google.com/compute/docs/ip-addresses/reserve-static-external-ip-address">Reserving a static external IP address</a>”, because they&#x27;re probably in the process of moving everyone from marketing into sales. You probably already guessed what Azure <a href="https://azure.microsoft.com/en-in/blog/reserved-ip-addresses/">calls it</a>. There&#x27;s also support rolling out for a newer larger address format called <a href="https://en.wikipedia.org/wiki/IPv6">IPv6</a> that&#x27;s four times longer and has more addresses than all the grains of sand on a billion earths—but that will take a little longer before it&#x27;s fully adopted. We&#x27;ll revisit IPv6 addressing again when we talk about more interesting deployment options.</p><p>Once we have an IP address, we log into the machine using SSH, install our code <em>package</em>, which can be as simple as a zip file for interpreted languages (like Ruby, Python or PHP), or a specially formatted zip file like <a href="https://en.wikipedia.org/wiki/JAR_(file_format)">JAR</a> or <a href="https://en.wikipedia.org/wiki/WAR_(file_format)">WAR</a> (Java &amp; JVM), or a compiled binary (Go, C++). We then complete the process of <em>deployment</em> by installing any dependencies or language runtimes we need, and run the application with a <a href="https://www.linux.com/training-tutorials/understanding-and-using-systemd/">process</a> <a href="http://smarden.org/runit/">manager</a> so it stays running after we log out or restart.</p><p>We can then point a domain name, like <em><a href="http://www.example.com">www.example.com</a></em>, at the IP address of our server has using the <a href="https://en.wikipedia.org/wiki/Name_server">name-servers</a> provided by company that we registered the domain name with. Or we could use the DNS name-servers offered by the cloud providers, which promise better performance all over the world. AWS has <a href="https://aws.amazon.com/route53/">Route53</a> (named after the default port for a DNS name-server, which is 53), Google has <a href="https://cloud.google.com/dns">Cloud DNS</a> and Azure just has <a href="https://docs.microsoft.com/en-us/azure/dns/dns-overview">DNS</a>. Using the cloud providers is helpful because they&#x27;ve got servers deployed all over the word, and DNS speeds make a big difference in how fast your application works for users everywhere. Route53 has a few advantages here—besides just answering the question of which IP address is serving a particular domain name, it also gives you the option to tailor that answer based on where the user is, letting you send them to a deployment that&#x27;s close to them. This assumes that you have a global application that&#x27;s deployed in multiple places across the world, of course. <a href="https://www.cloudflare.com/">Cloudflare</a> is also an excellent DNS provider—they also have a deployment offering that we&#x27;ll cover later.</p><p>Along with some extra work that I really hope you do, like OS firewalls and OS hardening, this completes a basic application server setup on the cloud. The cloud providers helpfully provide services to manage basic network security around your server, like AWS <a href="https://aws.amazon.com/vpc/">VPC</a>, Google <a href="https://cloud.google.com/vpc/docs/firewalls">VPC</a>, or Azure <a href="https://azure.microsoft.com/en-in/services/virtual-network/">Virtual Network</a>. All of these will allow you to selectively open and close ports with allow/block rules that be scoped to IP addresses; or scoped to another group of similarly managed servers (often called a <em>security group</em>). There are also pre-hardened cloud-specific OS distributions like <a href="https://aws.amazon.com/amazon-linux-2/">Amazon Linux</a> available for free use.</p><p>To see what&#x27;s going on with your application, or <em>monitor</em> it, you could always log in to the machine and read, or <em>tail</em>, the logs. But there&#x27;s another building block that cloud companies will give you—a tool to ingest logs, set up alerts and dashboards on them and archive them if necessary. AWS <a href="https://aws.amazon.com/cloudwatch/">CloudWatch</a>, Google <a href="https://cloud.google.com/logging">Cloud Logging</a>, and Azure <a href="https://docs.microsoft.com/en-us/azure/azure-monitor/overview">Monitor</a> all provide these features, usually charging based on the quantity of logs you ingest into them and how long you hold them for. Each of them have different features, but as a starting point it&#x27;ll make sense to just use whatever is available with your chosen platform. Each platform&#x27;s logging tool will usually also handle native metrics for you—you&#x27;ll be able to make a dashboard of server CPU usage, disk utilization, or any other metric that the cloud provider tracks natively. If you need more than this, companies like <a href="https://www.datadoghq.com/">Datadog</a>, <a href="https://www.sumologic.com/">Sumo Logic</a>, <a href="https://newrelic.com/">New Relic</a>, <a href="https://www.elastic.co/what-is/elk-stack">Elastic</a> and many others can also help.</p><h2>Protocols &amp; Encryption</h2><p>Before move on to more complex deployments, it&#x27;s important to review what kinds of incoming requests our applications might be dealing with in the first place. The common protocols we use are:</p><ul><li><strong>UDP</strong>, where <a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">packets</a> of information are sent to an IP address with no expectation of acknowledgement.</li><li><strong>TCP</strong>, which <a href="https://searchnetworking.techtarget.com/definition/TCP">builds</a> on <em>UDP</em> to create the concept of a <em>connection</em>, where the sender and receiver work with ordered packets of information that are all acknowledged—this gives the sender and receiver the impression of having a 2-way reliable sequential stream on which to exchange raw bytes.</li><li><strong>HTTP/1</strong>, which <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP">builds</a> on <em>TCP</em> to add the concept of a <em>request</em> and <em>response.</em> A <em>request</em> is sent to a human readable address, called a URL, with <em>headers</em> that act as key-value metadata and an optional <em>body</em> of bytes. Each request gets a response, with the same format of headers and body. Each request &amp; response runs on one TCP connection.</li><li><strong>WebSocket</strong>, which <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket"></a><a href="https://www.ably.io/topic/websockets">builds</a> on TCP to provide a similar 2-way ordered data stream, but instead of raw bytes the protocol allows for distinct messages to be sent. Each message is either received as a whole, or the connection is considered to have failed. WebSocket is a companion protocol to HTTP, and a HTTP connection is often transformed (<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Protocol_upgrade_mechanism">technically</a> <em>upgraded</em>) into a WebSocket.</li><li><strong>HTTP/2</strong>, which builds on <em>TCP</em> and offers the same features as HTTP/1, <a href="https://www.digitalocean.com/community/tutorials/http-1-1-vs-http-2-what-s-the-difference">but with better</a> performance, connection <em>multiplexing</em> (more than one HTTP request-response exchanges can happen simultaneously on the same TCP connection), header compression, and preemptive data <a href="https://www.smashingmagazine.com/2017/04/guide-http2-server-push/">pushing</a> from the server.</li><li><strong>gRPC</strong>, which <a href="https://grpc.io/"></a><a href="https://grpc.io/docs/what-is-grpc/core-concepts/"></a><a href="https://grpc.io/docs/what-is-grpc/core-concepts/">builds</a> on <em>HTTP/2</em> to offer remote procedure calls—a way for clients to call functions on servers, identified by URI, with an input and output exchanged in predetermined binary formats.</li><li><strong>HTTP/3 + QUIC</strong>, which builds on <em>UDP</em> and offers the same features as HTTP/2 but <a href="https://blog.cloudflare.com/http3-the-past-present-and-future/"></a><a href="https://blog.cloudflare.com/http3-the-past-present-and-future/">better</a>.</li><li><strong>TLS/SSL</strong>, which isn&#x27;t a standalone protocol, but a <a href="https://www.cloudflare.com/learning/ssl/what-happens-in-a-tls-handshake/">way to encrypt</a> and secure TCP and all the protocols that are built on it (which is all of them except UDP). This is pretty much a basic necessity these days—most browsers will make users deeply ashamed of visiting your site if it&#x27;s not encrypted, and some mobile OSs will just <a href="https://android-developers.googleblog.com/2018/04/protecting-users-with-tls-by-default-in.html">flat-out</a> <a href="https://developer.apple.com/documentation/security/preventing_insecure_network_connections">refuse</a> to make a connection with an non-encrypted server.</li></ul><p>It&#x27;s also worth re-visiting how trust-based encryption on the web works: the foundation of the secure web is a <a href="https://en.wikipedia.org/wiki/Certificate_authority">small group</a> of (hopefully) very competent companies, called <em>certificate authorities</em>, who <a href="https://www.thesslstore.com/knowledgebase/ssl-support/ca-bundle/">publish</a> public keys that every major browser and operating system decide to trust. When we want to use TLS, we <a href="https://www.sslshopper.com/article-most-common-openssl-commands.html">generate</a> a <a href="https://www.youtube.com/watch?v=AQDCe585Lnc&amp;vl=en">private key and public key pair</a>, and then <a href="https://letsencrypt.org/docs/challenge-types/">convince</a> one of these companies that this key pair is going to be used on one particular domain name that we control. After we provide enough proof, and <a href="https://letsencrypt.org/">sometimes</a> <a href="https://ssl.comodo.com/ssl-ev-certificates-extended-validation">money</a>, the company will issue a <a href="https://en.wikipedia.org/wiki/X.509"><em>certificate</em></a> that says they trust that we will indeed use that key-pair on that particular domain name. We present this certificate, which includes our public key, to all clients to earn their indirect trust—and since we have the private key accessible to our application servers we can then <a href="https://tls13.ulfheim.net/">enjoy fully encrypted</a> connections with the TLS protocol.</p><h2>Complex IaaS</h2><p>No server that we build, own, or rent from a cloud provider is ever a perfect machine—at some point something is going to fail. And even if we don&#x27;t care about failures too much, we&#x27;re often in situations where we want to run the same application on multiple servers—if not as backups, at least to handle more load than a single server can manage. At this point our deployment starts to get a little more complex—we can set up multiple servers easily enough, but we now need a new system to <em>load balance</em> (evenly spread) and <em>fail-over</em> (ignore the servers that aren&#x27;t working) incoming requests between our servers.</p><p>The system that we use to balance requests between our servers must support balancing the protocol(s) that we&#x27;re using in our application. This is actually pretty difficult to do correctly—because the system is going to be acting as a proxy, it needs to be as <em>transparent</em> as possible: both in terms of performance and modifications to the requests and responses. It should be so fast and meddle so little with the connections that our applications and users experience no problems from using it.</p><p>We also want this load-balancing system to handle <em>TLS/SSL termination</em>. Our applications may be able to handle encryption/decryption themselves, but we don&#x27;t actually want the private key accessible to our application servers—that&#x27;s a security nightmare. We also don&#x27;t want to worry about making sure our chosen language or framework does a good &amp; fast job encrypting/decrypting connections—especially if we chose the language for its strengths in other areas. With <em>TLS termination</em>, the load-balancer handles the encryption/decryption of all the connections, forwarding just a normal non-encrypted connection to our application. This way, our application servers don&#x27;t need to be concerned any of this stuff—the work is contained in the load-balancers that know how to do it fast, securely, and well. Lots of cloud providers and load-balancers will also provide automated certificate management, usually integrating with the free <a href="https://letsencrypt.org/">Let&#x27;s Encrypt</a> authority. AWS is also an authority themselves with their free <a href="https://aws.amazon.com/certificate-manager/">ACM</a> service.</p><p>Open source tools like <a href="https://www.nginx.com/">Nginx</a>, <a href="https://www.haproxy.org/">HAProxy</a> are available to do load balancing, along with specialized hardware from companies like <a href="https://www.f5.com/">F5</a>—each of these systems will support all or some subset of the protocols and features above. But here we&#x27;re more interested in how the cloud providers can help us handle this, so let&#x27;s jump to that:</p><h3>Network/L4 Load Balancers</h3><p>The most transparent load balancing system on AWS is the <a href="https://aws.amazon.com/elasticloadbalancing/network-load-balancer/">Network Load Balancer</a>. You pay a base monthly charge, and AWS will set up, manage, and scale a fleet of servers that load balance at a UDP and TCP level, called <em>Layer 4</em>—which means that all protocols built on TCP &amp; UDP will also work. The NLB is known to be very fast and is so transparent that you literally won&#x27;t know it&#x27;s there—your application will see the IP address of your clients as the origin of the connection as if there wasn&#x27;t a load-balancer in the middle. The NLB does TLS termination as well, <a href="https://aws.amazon.com/blogs/aws/new-tls-termination-for-network-load-balancers/">integrating</a> with the <a href="https://aws.amazon.com/certificate-manager/">ACM</a> to automatically issue and manage your certificates. The service will automatically scale up and down, charging you a multiple of about half-a-cent every hour, based on the maximum of three metrics—either new connections made, or existing active connections, or data transferred. Google also has a <a href="https://cloud.google.com/load-balancing/docs/network"></a><a href="https://cloud.google.com/load-balancing/docs/network">network load balancer</a> that behaves similarly to the one AWS offers, but as of this writing it does not support automated certificate management. You&#x27;ll need to get your own certificate, upload it, and keep it renewed periodically. The <a href="https://docs.microsoft.com/en-us/azure/load-balancer/load-balancer-overview">Azure Load Balancer</a> works similarly as well, except it doesn&#x27;t seem to support TLS termination at all.</p><h3>Application/L7 Load Balancers</h3><p>The next kind of load balancing system works at the HTTP level, or <a href="https://www.cloudflare.com/en-in/learning/ddos/glossary/open-systems-interconnection-model-osi/">Layer 7</a>. These systems actually read the data in the incoming requests, assuming that they&#x27;re HTTP (or based on HTTP), hold the connection, and initiate a separate request to the application with the same data mapped on to it. While this results in some transparency loss—the process is slightly slower, and the source IP address you see is now the IP address of the load balancing server—there are also many advantages:</p><ul><li>the load-balancer can now <em>multiplex</em> multiple domain names to applications, by examining the <em>host</em> headers and deciding which application this request should go to.</li><li>it can route requests to different applications or modules of an application depending on the <em>path</em> of the request address.</li><li>it can apply a rules engine to do advanced functions like redirects, checking for the presence and validity of authorization tokens, or anything else you might want across all requests and applications.</li><li>it can compensate for the loss the source IP address transparency by injecting it into the request headers, usually in <code>X-Forwarded-For</code>.</li></ul><p>One caveat with L7 load-balancers, though, is that protocol support doesn&#x27;t flow upward like it does with TCP &amp; network load-balancers—they need to have separate support and handling for HTTP/1, WebSockets, HTTP/2, gRPC and HTTP/3. These protocols share a common ancestor in TCP, but understanding one does not guarantee that a system will understand any of the others. Each L7 load balancer will support a subset of these protocols.</p><p>The AWS service offering this kind of L7 system is called the <a href="https://aws.amazon.com/elasticloadbalancing/application-load-balancer/">Application Load Balancer</a> and it&#x27;s priced similarly to the NLB, but a little more expensive. It supports incoming connections in HTTP/1, HTTP/2, WebSockets and gRPC, with the option to proxy them forward to your application in the same protocols (after optional TLS termination) or downgrade HTTP/2 to HTTP/1. This way if your application framework only supports HTTP/1 you can still enjoy some of the benefits of HTTP/2. It also supports routing rules based on host, path, method, query parameter, source IP and arbitrary headers; and can automatically validate authorization tokens with a bunch of identity providers.</p><p>Google&#x27;s <a href="https://cloud.google.com/load-balancing">Cloud Load Balancing</a> system supports HTTP/1, HTTP/2, gRPC and also HTTP/3+QUIC—with host and path based routing. It also has the advantage of being global—it publishes a single IP address that Google&#x27;s servers worldwide respond to, and requests are forwarded to the nearest configured application server. It provides TLS termination and has options for both automated and self managed certificates. There&#x27;s also deep integration with Google <a href="https://cloud.google.com/cdn/">Cloud CDN</a>.</p><p>The AWS answer to the Google&#x27;s load balancing being global is the <a href="https://aws.amazon.com/global-accelerator">Global Accelerator</a>—a kind of worldwide load-balancer of load-balancers that gives you two IP addresses that will route to many AWS servers all over the world, which will then forward the connection to the nearest configured application server or NLB/ALB. On the <a href="https://www.cloudflare.com/learning/cdn/what-is-a-cdn/">CDN</a> side, AWS <a href="https://aws.amazon.com/cloudfront/">CloudFront</a> works great by itself, but doesn&#x27;t have much integration with either the ALB or Global Accelerator.</p><p>Azure answers all this with <a href="https://docs.microsoft.com/en-us/azure/frontdoor/front-door-overview">Front Door</a>, which does a little bit of everything—support for HTTP/2, but <em>not</em> WebSockets, no word on gRPC with routing based on hosts and paths.</p><h3>Automatic Scaling</h3><p>Once you&#x27;ve chosen a load balancing system, the complementary decision is if and how to automatically change the number of servers you&#x27;re running, based on some inputs. The first step do doing this is to figure how to automate setting up a new server. The manual way to do it is to SSH into it and run the commands one by one, and one way to automate that would be to write those commands into a shell script that can be run on any new machine, performing all the necessary setup and configuration. The cloud providers will allow you to specify this shell script as a <em>launch script</em>, automatically running it when a new server boots up for the first time.</p><p>There&#x27;s also often the option of taking a fully functioning server and treating it as a prototype of sorts, by cloning its root hard drive as is and then running each new server with a clone of that drive. There are also widely available configuration and installation tools—any method will work fine, but we need to choose one.</p><p>Once we&#x27;ve figured out how a new server is going to be setup automatically, AWS, Google and Azure then offer to automatically add new servers when certain rules are met, and automatically attach those servers to your configured load-balancer. This means that when the work your application needs to do increases, you don&#x27;t need to get involved in any way—the cloud control systems will automatically spin new servers up to handle the extra load. The most common rule is CPU utilization, where you say new servers need to be added if the average utilization over some number of minutes goes over some limit, say 75% over 5 minutes. There are other triggers and rules possible as well, like those based on memory utilization, network bandwidth—or even rules based on external factors, like the time of day, number of pending messages in a queue, or signals from any other system.</p><p>You&#x27;ll always be able to set a limit on the expansion of your servers, so you won&#x27;t be shocked by a massive bill later. The reverse of the scaling operations is also available and can be automatic—servers can be removed when the CPU utilization drops below 30% for 10 minutes, for example, or any other rule that&#x27;s usually the inverse of what you set up in the scaling up operations. It&#x27;s also normal to set a minimum limit as well, because going down to zero will usually mess with the metrics you&#x27;re using to scale up and down—not to mention make your application completely unavailable.</p><p>The rule of thumb I use for web applications is to add servers when CPU utilization is 70% for over 5 minutes, and drop servers when it&#x27;s lower than 30% for 10 minutes—but there are infinite ways to set this up, and it&#x27;s very dependent on your application. For servers that process jobs I hook up a rule to add more servers if the number of messages in the queue goes over a few hundred, and drop servers if there are less than hundred messages. The minimum is usually two servers, and I set the max according to what my <a href="understanding-connections-pools/index.html">database can handle</a>.</p><h2>Packing Progress</h2><p>The options we&#x27;ve covered up to this point are generally referred to as IaaS, or <em>infrastructure as a service</em>. These providers give you the option to rent servers and a few other services, but how they&#x27;re used and set up in entirely up to you.</p><p>One the earliest options to go one step further was <a href="https://www.heroku.com/">Heroku</a>—initially built to host Rails applications, Heroku took the Rails ideas of convention over configuration and applied them to server deployment, promising that if you had a conventional Rails application they would use that knowledge to handle packaging and deployment tasks for you. You just had to give Heroku access to your code folder or repository, and it would package the code into a simple custom format (called a <em>slug</em>) on Heroku servers, and run it for you on fully managed virtual servers called <em>dynos</em>. An environment variable called <code>PORT</code> would be injected into your application, and you just needed to serve your requests on that port. A common load-balancing and routing layer would handle all requests and send them to your app, so there was no separate load-balancer to configure—you could simply choose the number of app servers you wanted to run and it would happen. All the logs your application wrote to STDOUT (<em>standard output</em>, the default Unix destination for log / print statements in your code) would be automatically captured and consolidated for you in a dashboard and CLI.</p><p>This form of simplified and opinionated hosting became known as a platform-as-a-service, or PaaS. Heroku then branched out to other application stacks and framework by <a href="https://devcenter.heroku.com/articles/platform-api-deploying-slugs">defining the packaging format</a>, the <em>slug</em>, a little better. A series of shell scripts, called <em><a href="https://devcenter.heroku.com/articles/buildpacks">buildpacks</a></em>, were then written to build many common application types into the standard <em>slug</em> format. Assuming your code ran correctly on the same underlying OS and dependency list, or <em><a href="https://devcenter.heroku.com/articles/stack">stack</a></em>, that Heroku used, it could just build a <em>slug</em> with a suitable <em>buildpack</em> and deploy it.</p><p>Other attempts were made to standardize the Heroku slug format, but it never caught on broadly. Luckily, there was a different packaging format being developed that would go on to revolutionize how applications were packaged and deployed. When packaging code ourselves, we write scripts and commands to install the full set of dependencies that we needed to run our application, install the application itself, and set up the process manager. Each of these steps is error prone—versions can change, network downloads might timeout, and the dependency environment isn&#x27;t guaranteed to be the same as our development machines, or the runtime environment might change from one application server to the next depending on whether some OS patches are installed. Heroku solved some of these problems by <em>vendoring</em>—building the <em>slug</em> downloaded all the dependencies and binaries an application needed into the folder that the code resided in. But it was still a relatively incomplete solution, because it didn&#x27;t deal with the OS and compatibility problems between different development and deployment environments.</p><p>A solution to standardize packaging completely was introduced with <a href="https://www.docker.com/">Docker</a>, using <em>containers</em>, which offered a way to fully standardize the OS, patches, dependencies, application code and configuration setup—all in a way that a container could be created right on the local development machine. A <em>container</em> created this way would run exactly the same on any server—with clean options available to configure each environment and hook up foundation services like log collection. Since the introduction of Docker there have also been <a href="https://coreos.com/rkt/">other</a> advances and standards that have built on this idea, including a way to <a href="https://buildpacks.io/">make containers from buildpacks</a>—so now we have a full ecosystem of options for <em>packaging</em> code. When we package code into containers, they can run on any platform with no regard to the underlying OS stack.</p><p>This is a big deal, and it opens up a lot of deployment options. If you&#x27;re trying to deploying a full package like a container, cloud companies can now get creative in how they can then take that package and run it for you. This gave rise to the idea of <em>orchestration</em>, which allows you to use your severs as one giant pool, or cluster, of computing capacity—and run as few or as many containers as you need for each of your applications, in that cluster. An orchestrator can handle your deployments, keep track of which servers have which containers running on them, which servers have capacity available to run more, where the best place is to run the next container, and the list of containers and their IP address / port combinations that are running as part of each application. These orchestrators can then provide their own load balancing systems, or integrate with the existing load balancers on offer. This entire containerization &amp; orchestration ecosystem allows you to abstract away the concept of a server—it doesn&#x27;t matter what OS or version or software is installed on each server, because any server that has the orchestrator&#x27;s <em>agent</em> installed is now a source or raw computing power that and be added into your resource pool. Your applications will bundle the OS and dependencies of their choice along with code, so they don&#x27;t care at all about where or what they&#x27;re running on.</p><h3>ECS</h3><p>The <a href="https://aws.amazon.com/ecs/?whats-new-cards.sort-by=item.additionalFields.postDateTime&amp;whats-new-cards.sort-order=desc&amp;ecs-blogs.sort-by=item.additionalFields.createdDate&amp;ecs-blogs.sort-order=desc">Elastic Container Service</a> was one of first orchestrators that became available, specific to AWS. It fully integrates with the AWS ecosystem, including pulling your container images from the AWS-native <a href="https://aws.amazon.com/ecr/">ECR</a> repository, auto-scaling, attach/detach to the ALB/NLB load-balancers, logging integrated with the CloudWatch logging system and more. ECS works by asking you to <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-agent-install.html">install an ECS agent</a> on your pool of servers, and using that agent to manage the containers running on them. There&#x27;s also a fully <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-optimized_AMI.html">optimized OS image</a> available with the agent preinstalled. There&#x27;s also the option of installing the agent on <a href="https://aws.amazon.com/blogs/containers/introducing-amazon-ecs-anywhere/">other servers anywhere</a> else that you might control, seamlessly adding that capacity into your ECS cluster.</p><p>You can then setup <em>services</em> and <em>tasks</em> on ECS. <em>Services</em> are continuously running containers that can serve web requests or do continuous work, while <em>tasks</em> are periodic or one-time runs of a container that are expected to do some work and then shut down. ECS will intelligently spread your services and tasks over all the servers in your cluster using <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-placement-strategies.html">strategies</a> that you can customize. You can apply auto-scaling policies to your services, and have them attached automatically to load-balancers. With plain ECS, you need to make sure that your cluster is large enough to run all the containers you want—the simple way to do this would be to run an auto-scaling fleet of servers based on the <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-optimized_AMI.html">ECS optimized OS image</a> that are instructed to join your cluster in their launch script.  </p><h3>Kubernetes</h3><p>Initially developed at Google, Kubernetes is now a very popular container orchestrator that you can run yourself on pretty much any cloud, with fully managed service being provided by the big three via <a href="https://aws.amazon.com/eks/">EKS</a>, <a href="https://cloud.google.com/kubernetes-engine">GKE</a>, and <a href="https://azure.microsoft.com/en-in/services/kubernetes-service/">AKS</a>. Your underlying servers that provide capacity are called the <em>cluster</em>, and each application unit that you run is called a <em>pod</em>. Containers are generally considered disposable and <em>stateles_s</em>—<em>any important data you have is not stored on the container file system itself, but in the database or any common storage system. Kubernetes has separate provisions for _pods</em> that do in fact store information locally, which makes them <em>stateful</em>. As with ECS, you&#x27;ll need to make sure your cluster is adequately supplied with underlying servers, and each engine will have its own methods to do this.</p><h2>Servers are so PaaSé</h2><p>Once we have cloud-managed orchestrators running our deployments on our server clusters, the obvious question arises—why do we need to manage these underlying servers in the first place? If these orchestrators are running on the cloud and the cloud companies are managing all these servers anyway, why not just integrate server management? That&#x27;s exactly what AWS and Google have done with AWS <a href="https://aws.amazon.com/fargate/">Fargate</a> and Google <a href="https://cloud.google.com/run">Cloud Run</a>. These services allow you to set up your applications, specify how much CPU and RAM each container needs, and just let the cloud provider figure it out. They&#x27;ll treat their entire fleet of servers as one gigantic pool or cluster and give you exactly the capacity you need. They also apply their security experience to make sure your applications are completely isolated, even if they&#x27;re all technically running in the same cluster.</p><h3>Fargate</h3><p>AWS <a href="https://aws.amazon.com/fargate/">Fargate</a> runs on the ECS system, where you can choose Fargate as the basis of your cluster instead of adding &amp; managing a group of servers with the ECS agent installed. AWS will handle cluster management while still making sure that each service and task works with the same network security rules and configurations as managing the underlying servers yourself. Fargate also has the option of using an interruptible cluster at a much cheaper rate. If you have applications that can tolerate its services being shut down and restarted, you can set up Fargate to use the <a href="https://aws.amazon.com/blogs/aws/aws-fargate-spot-now-generally-available/">spot market capacity provider</a> with higher priority, and then the regular Fargate provider. The normal ECS integrations with the load-balancers and logging are available.</p><h3>Cloud Run</h3><p>Google goes one step further with <a href="https://cloud.google.com/run">Cloud Run</a>, a service that fully integrates a load-balancer and router as well, so your application receives a URL and can start and stop as many containers are required, even doing a full shutdown if no requests have come in in a while. If a request comes into Cloud Run app while no containers a running, the special load-balancer / router will hold the request open while a container is quickly started, and then pass the request into your application. This allows you to run intermittent web services without having to pay when you&#x27;re not serving any requests.</p><h3>Heroku</h3><p>Heroku has added support for Docker as well, so it has the distinction of being a full service PaaS whether or not your application is packaged using Docker. Containers are supported as is, while any app that can be built with a <a href="https://devcenter.heroku.com/articles/buildpacks">buildpack</a> and can run on Heroku&#x27;s <a href="https://devcenter.heroku.com/articles/stack">stack</a> is supported. Heroku also adds a lot of integrated functionality using <a href="https://elements.heroku.com/addons">add-ons</a>—since they&#x27;re not themselves a major cloud provider they encourage integrated third-party services over trying to offer everything themselves.</p><h3>Fly</h3><p>There&#x27;s also another interesting upstart startup that does something similar to Google&#x27;s Cloud Run, called <a href="https://fly.io/">Fly</a>—upload your container and Fly will run it for you with a builtin load-balancer and logging. Fly has the added advantage of being global—you can choose to deploy your containers in any subset of the ~20 <a href="https://fly.io/docs/reference/regions/">regions</a> Fly has all over the world. When your users make a request to an app on Fly it&#x27;ll land in the closest Fly region, and Fly will service it from the nearest running container—while also examining your traffic patterns and intelligently starting and stopping containers all over the world for you. Besides the obvious HTTP traffic Fly can also handle TCP, UDP and <a href="https://fly.io/docs/app-guides/grpc-and-grpc-web-services/">gRPC</a> connections, so if your application benefits from running close to your users wherever they are, it&#x27;s a great choice. Fly lets you choose the VM size your container will deploy in, and charges by the second for running VMs. It does <em>not</em> currently support scaling down to zero, but the base VMs are available for a very low price—and since the load-balancer is included it&#x27;s pretty cheap to run an application there. Unlike other PaaS systems, Fly also offers <a href="https://fly.io/docs/reference/services/">networking services</a> between all running instances of your container, so applications that need to communicate internally can work especially well. <a href="https://fly.io/blog/ipv6-wireguard-peering/">IPv6 &amp; Wireguard are used to great effect</a> to build a private network of your running containers that you can also connect to from outside of Fly.</p><h3>Google App Engine</h3><p>App Engine was the original Google PaaS, active well before the rest of the Cloud systems. App Engine supports a lot of language <a href="https://cloud.google.com/appengine/docs/standard/runtimes">runtimes</a>, as well as a Docker based <a href="https://cloud.google.com/appengine/docs/flexible">flexible environment</a>. It comes with heavily integrated load balancing, automatic scaling up and down, datastore servcies, and integrated logging. It also <a href="https://cloud.google.com/appengine/docs/standard/go/reference/request-response-headers">injects useful information</a> about clients into the the incoming HTTP request headers, like approximate location, city, state and country.</p><h2>FaaSt &amp; Furious</h2><p>Alongside the advances in packaging and orchestration, cloud companies have also been working, in parallel, on a another way of running code—you give them the code, and they run it. That is, of course, assuming you make sure it follows a particular API, uses a particular technology stack, is packaged a particular way, and operates correctly within strict limits. If your code can twist itself into all these requirements, the cloud will do something magical with it in return: it will run your code exactly when necessary, charge you for exactly how much time it runs, and do it instantly at any level of scale you can imagine—all without you ever having to think about the word ‘server’.</p><p>The cloud companies do this by first creating a smart event router—when an event comes to the router and needs your code to process it, the router will see if your code is already running in a <em>slot</em>. I&#x27;m making up the word <em>slot</em> here—I have no idea what they&#x27;re called internally. But these companies join the router with custom orchestrators that create a huge pool of secure, isolated execution <em>slots</em> on thousands or millions of their machines—when an event comes to the router and needs to be processed, the router looks to see if any of these slots is running your code. If none are, your code is loaded up from common network storage and initialized in a slot. The event is then passed as an input to your code, and after it finishes executing the output is routed to wherever it needs to go. Your code may be kept running in the slot for a while, in the hope that it might be used again soon, or the slot might be cleared and used with some other code.</p><p>Now you can see why the companies place such stringent restrictions on your code—because the service has no idea which slot your code is going to run in, all the slot servers have the same OS, and same short list of standardized dependencies and fixed language runtimes preinstalled. All the slots follow exactly the same input-output API, where the code must receive the input event in a certain format, and emit the output in a fixed format as well. Your code package has to be small enough to quickly load up, over the network, into any slot on any server. It needs to finish execution fast, because it&#x27;s incredibly hard to fairly schedule slots across all the customers or plan capacity changes if your code is going to occupy slots indefinitely.</p><p>But this also means that you can write your code with absolutely no worry about scale or servers or anything of that sort. Your code can run as seldom as necessary, like a report once a year, or millions of times a second, like global order processing on a holiday. You&#x27;ll still pay for exactly the amount of time (in milliseconds) that your code is actually executing for.</p><p>This makes for some very interesting use cases—while the benefit to code that runs intermittently is obvious, there&#x27;s also a use case here for code that runs in a very spiky way—like a popular play that opens ticket sales every Thursday morning at 10AM, or a popular news outlet unsure of when something big might happen. Most applications in these scenarios need to be provisioned, or scaled up, to handle their peak traffic even when they&#x27;re not actually doing so—because when they do need to suddenly handle the extra load there might not be time to add more servers.</p><p>This has also allowed a <a href="https://www.stedi.com">new cloud-native companies</a> to maintain so much <a href="https://twitter.com/zackkanter/status/1347389071388073985?s=21">accounting rigor</a> that they know exactly how much it costs to do each and every one of their pieces of work across every customer—and therefore have complete and up-to-the-minute knowledge of their revenue, costs and margins at all times. The nature of FaaS billing, where you&#x27;re charged exactly per operation, is particularly conducive to this—especially when paired with <a href="https://aws.amazon.com/dynamodb/pricing/on-demand/">databases that work the same way</a>. And they can do all this without a separate on-call ops team.</p><p>As far as performance goes, one thing to remember is each slot can only serve one request at a time in FaaS systems, even if your language and stack are multi-threaded. The CPU that you slot runs on might have multiple cores, and you may be able to utilize all those cores while processing a request, but each slot will only process one request at a time. This isn&#x27;t usually a problem—the promise of a FaaS is being able to use as many slots as you need automatically. The flip side is that each new slot coming up needs a <em>warm up time</em>—you&#x27;ll remember that you code might have to be loaded over network storage, unzipped and initialized. Some FaaS systems might offer to always keep a few slots warmed up for you for an extra charge.</p><h3>Lambda</h3><p>AWS <a href="https://aws.amazon.com/lambda/">Lambda</a> is one of the most popular FaaS services. Initially the request router could only handle events from internal sources, like the AWS <a href="https://aws.amazon.com/sqs/">SQS</a> message queue—but integration with other services like the ALB load balancer or API Gateway now allows these services to <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html">convert incoming HTTP requests</a> into events that Lambda can work with. Once your code processes this HTTP request event, it gives out the response as event data as well, which the integrating service then coverts into a HTTP response—on the connection that they&#x27;ve been holding all this while in a waiting state. This way your clients can&#x27;t tell the difference between you serving requests off a Lambda or a regular server / container. As you can imagine, this approach only supports HTTP requests—although AWS has other related services that <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api.html">provide WebSocket support</a> controlled via API calls. Lambda can <a href="https://aws.amazon.com/blogs/aws/new-provisioned-concurrency-for-lambda-functions/">keep a set number of slots warmed up</a> at all times for an extra charge.</p><h3>Google Cloud Functions</h3><p>Google <a href="https://cloud.google.com/functions">Cloud Functions</a> behave very similar to the AWS Lambda system, but they have much better first-class integration with HTTP triggering mechanisms—there&#x27;s no need to set up any other service to use them to respond to HTTP requests, like there is with Lambda.</p><p>Azure has <a href="https://azure.microsoft.com/en-in/services/functions/">Functions</a> too.</p><h3>Cloudflare Workers</h3><p>Besides being an excellent DNS and CDN service, <a href="https://www.cloudflare.com/">Cloudflare</a> also recently introduced a global compute service, called <a href="https://workers.cloudflare.com">Workers</a>. Since they already have servers deployed in hundreds of cities worldwide for the CDN and DNS, it makes sense to offer them up for computing work as well. The normal approach is useless here, though—when running a large number of deployments, each individual deployment of servers isn&#x27;t very big—definitely not a full data-center. This means that giving customers the option to run full-blown applications or containers isn&#x27;t feasible—there simply wouldn&#x27;t be enough CPU, RAM and performance for everyone. What Cloudflare did instead was <a href="https://developers.cloudflare.com/workers/learning/how-workers-works">use the V8 Engine</a> that powers the Chrome browser and NodeJS. V8 has a way to run arbitrary code in a secure sandbox called an <em>isolate</em>. Using this feature allows Cloudflare to run compute workers for many customers without paying a process or memory penalty. Isolates are also extremely fast, and since the code is just JavaScript, or other languages compiled to <a href="https://webassembly.org">WASM</a>, loading it up is very quick—which is probably helped even more by Cloudflare likely holding all code in the same fast storage as CDN data. Cloudflare also mitigates the event format problem by using the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API">standard Service Worker API</a>. This means that if you write JS (or compile WASM) code implementing the Service Worker API, you can upload it to Cloudflare, and they&#x27;ll store a copy in all of their <em>edges</em> all over the world. When a request comes in, it&#x27;s serviced by the edge closest to the user, and they can load up your code and execute it to return responses directly from that edge. This helps you write applications that can return responses within low tens of milliseconds to almost anywhere in the world, which is impossible in a regular single deployment because the speed of light is so slow.</p><h3>Downside Mitigations</h3><p>There are three big downsides to FaaS systems, the first of which is the warm-up time. Lambda has options available to keep warm slots running at all times, and there&#x27;s constant work going on in every service to cut down the startup and initialization times. Any conversation about performance is probably going to be out-of-date immediately, because the companies are working every day to make things better. The good news is that this problem will get smaller and smaller automatically as the companies figure things out.</p><p>The second problem is that of the limited stack and dependencies available. Lambda has a lot more options here, with the <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">Layers</a> feature allowing you to add arbitrary binaries into your deployment, helping support languages and runtimes not on the <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html">official list</a>. Lambda is also going one step further with <a href="https://aws.amazon.com/blogs/aws/new-for-aws-lambda-container-image-support/">support for containers</a>—subject to choosing one of the predefined base images. It&#x27;s possible Google might do something similar, but this is probably about as far as the technology can be pushed, given its fundamental conceptual limits.</p><p>The third problem is the need for a custom event format. If you&#x27;re writing new code from scratch and want to use them only on your FaaS of choice, this might be fine. But if you&#x27;re more used to stand-alone applications, or want to also have the option of a regular deployment off the same codebase, things get a bit more complicated. If you&#x27;re using a language like Ruby, your application likely runs on the <a href="https://thoughtbot.com/upcase/videos/rack">Rack protocol</a>. This allows a tool like <a href="https://lamby.custominktech.com">Lamby</a> to work as the Lambda event handler, internally converting it into a Rack request, having your application handle it, and converting the outgoing Rack response into the Lambda response event format. If you&#x27;re stuck with a tech stack that can&#x27;t do this—where the HTTP server is part of the application itself—a tool like <a href="https://apex.sh/docs/up/">Up</a> can work—it runs your application as a process and places itself as the event handler. It then converts the event into an actual HTTP request and sends it into your application, doing the reverse with the response. It adds a very small latency to every request, but that&#x27;s so small it&#x27;s hard to measure. The idea of converting a HTTP request to a FaaS event and then to a HTTP request again, handling it with the application, and then converting the HTTP response into a FaaS event and then back to HTTP response again might sound weird, but if you want to do it you can. But none of this will work for non-HTTP protocols, of course.</p><h2>More Money, Less Problems</h2><p>There&#x27;s a lot of discussion, and often arguments, happening over which kind of system is the the most cost effective way to run applications. The sage advice, as always, is <em>“it depends”</em>. The problem with trying to find the answer to this question is that saying “Lambda is cheaper than running your own servers” and “running your own servers is cheaper than Lambda” are <em>both completely true</em>—depending on what kind of application and request load you&#x27;re looking at.</p><p>One we to think about this is understand that cost comparison is <em>not a single-dimensional problem</em>—it&#x27;s always <em>multi-dimensional</em>, not even two-dimensional. Let&#x27;s say you draw graph of cost of service vs requests-per-second load, for an IaaS system and a FaaS. Immediately you&#x27;ll see that the cost line of an IaaS starts above zero and goes up in steps (as you need to add more servers one by one), and the FaaS line starts at zero and goes up perfectly linearly, with a constant slope. Check out this amazingly beautiful and accurate drawing below, that I made myself:</p><pre><code>   ▲
 ┌─┴──┐
 │Cost│                                                        *
 └─┬──┘                                                    ***       ┌────┐
   │                                   ┌─────────────────**──────────┤IaaS├─
   │                                   │             ***             └────┘
   │                                   │          ***
   │                                   │      ***
   │                                   │  ***
   │                                   │***
   │                               ****│
   │                           *****   │
   │                        ****       │
   ├────────────────────****───────────┘
   │              *****
   │       ┌────┐**
   │       │FaaS│
   │   ****└────┘
   │ ***                                         ┌──────────────────────┐
   *─────────────────────────────────────────────┤ Requests per second  ├─▶
                                                 └──────────────────────┘
</code></pre><p>It&#x27;s immediately obvious that the FaaS or IaaS can both be cheaper, depending on what request-per-second value you&#x27;re looking at. And keep in mind that this is just two dimensions—requests-per-second is plotted on the X-axis here, but how do you plot the ability to scale to millions of requests when there&#x27;s a unexpected breaking news event, or a flash sale? How do you plot not having to wake up at two in the morning, when you&#x27;ve just put the baby to sleep, to clear logs because one of the cron jobs didn&#x27;t run often enough and one server out of fifteen has a full disk?</p><p>It&#x27;s not even possible to start a conversation unless you understand the (multiple) cost graphs for each kind of system, plotted against each of the X-axes that you care about. There are some very rough guidelines you can use, though:</p><p>On an <em>IaaS</em>, you&#x27;ll see costs rise in steps, as you add each server. Each server is a discrete and atomic chunk of cost, and whether enable auto-scaling or not, you&#x27;ll move up and down in steps based on your chosen server size. This means that you&#x27;ll always have some wastage, which is the area under the steps that runs even when you don&#x27;t need it. Also, auto-scaling systems will almost always scale linearly, even if the request load has suddenly jumped exponentially, so if you have a spiky workload you&#x27;ll often miss serving some requests as well. You also have a lot of work to do in setup, ops and maintenance, so you&#x27;ll need to account for that too, in terms of salaries, time, effort, opportunity cost and hiring difficulty.</p><p>On a <em>PaaS</em>, you&#x27;ll see a lot of the similar costs—the absolute dollar values will likely be higher, so whether this is worth it for you depends on how well you factored in other dimensions in the <em>IaaS</em> line. If you factored in the dimensions like your time, the ops team salaries and generally having a life, it becomes easier to judge accurately. PaaS costs tend to be very similar in shape to IaaS costs, but higher because they handle more of the setup, maintenance and ops work for you.</p><p><em>FaaS</em> pricing lines will tend to be very different, and will exactly track your X-axis values, whether you&#x27;ve chosen to plot against requests-per-second, bytes-transferred, CPU-used, or anything else. One distinctive feature is that they start at zero—so for very small values on the X-axis a FaaS will almost always be cheaper. FaaS systems can also handle very heavy load almost instantaneously, which depending on your use case may be priceless, and impossible to achieve with an IaaS or PaaS. They also have the advantage of being completely maintenance-free, with the providing cloud company also constantly improving service quality. But if you have a steady load, and it&#x27;s always higher than the baselines required to support a basic IaaS or PaaS deployment (load balancer monthly fees + 2 servers), maybe a FaaS isn&#x27;t a good idea—but depending on how highly you value ease-of-use it might still be.</p><p>So what&#x27;s best option? As always, it depends. There are no answers anywhere, other than at the end of your own evaluations. You can contact me <a href="https://twitter.com/sudhirj">@sudhirj</a> if you have a specific application you want an opinion for, or for any other questions, mistakes or disagreements.</p></article><footer class="py-10 text-gray-500 prose">Hi! I&#x27;m Sudhir Jonathan, I work as the Director of Engineering at <a href="https://www.qubewire.com">QubeWire</a>, and you can find me on <a href="https://twitter.com/sudhirj">Twitter</a>, <a href="https://github.com/sudhirj">Github</a>, and <a href="https://stackoverflow.com/users/73831/sudhir-jonathan">StackOverflow</a>. And on this blog, <a href="index.html">sudhir.io</a>. Subscribe to the <a href="https://tinyletter.com/sudhir-io">mailing list</a> if you&#x27;d like to be notified when I post new articles.</footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{}},"page":"/the-big-little-guide-to-running-code-in-the-clouds","query":{},"buildId":"pkInIokvrXIdaP_t5UMJ1","nextExport":true,"autoExport":true,"isFallback":false,"scriptLoader":[]}</script></body></html>